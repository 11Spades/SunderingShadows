#include <std.h>
#include <move.h>
#include <daemons.h>
#include <party.h>
#include "../../tecqumin.h"
#define DEST "/daemon/destinations_d.c"
#define OTHERSIDE "main_field"

inherit VAULT;

int check_open();

void create() {
  ::create();
  DEST->add_waystation( file_name(TO), file_name(TO), 1);
  DEST->add_waystation( file_name(TO), TABAXROOM + "centre", 2);
  DEST->add_waystation( file_name(TO), TABAXROOM + "northwest_corner", 2);
  DEST->add_waystation( file_name(TO), TABAXROOM + "southeast_corner", 2);
  DEST->add_waystation( file_name(TO), TABAXROOM + "southwest_corner", 2);
  set_short("Inside the stockade");
  set_items(([  "gate" : (:TO, "gate_desc" :)   ]));
  set_long("You are inside the %^ORANGE%^stockade%^RESET%^, standing before the main gateway. Just to"
          +" the side of the gate is the lever that activates the gate mechanism. You could use it to"
          +" open or close the gate. North, you can see the central area of the stockade. Further"
          +" north appears to be the main living area. To the east there is an area that looks like"
          +" it has been out of use for a while. To the west and north there appears to be a communal"
          +" eating area.");
  set_exits( ([ "west": TABAXROOM + "southwest_corner",
               "east": TABAXROOM + "southeast_corner",
               "north": TABAXROOM + "centre",
               "watch" : TABAXROOM + "watchtower",
               "bt5"   : TABAXROOM + "battlement5",
               "bt6"   : TABAXROOM + "battlement6",
               "bt7"   : TABAXROOM + "battlement7"
             ]) );
  if (check_open() == 1){
    add_exit(TABAXROOM + OTHERSIDE, "south");
  }
  set_invis_exits( ({"watch", "bt7", "bt6","bt5" }) );
  set_pre_exit_functions( ({"watch", "bt7", "bt6", "bt5"}),({"go_on", "go_on", "go_on", "go_on" }) );
}

void init(){
  ::init();
  add_action("open_gate", "pull");
  set_had_players(3);
  add_action("knock_gate", "knock");
}

int query_gate_open(){
  if (query_exit("south")==TABAXROOM + OTHERSIDE){
    return 1;
  }
  return 0;
}

string gate_desc(){
  object room;
  string desc;
  room = find_object_or_load(TABAXROOM + OTHERSIDE);
  desc = "The %^ORANGE%^stockade gate%^RESET%^ is tall, and robust looking, built from the strongest"
        +" timbers of the %^GREEN%^j%^BOLD%^%^GREEN%^u%^RESET%^%^GREEN%^ng%^BOLD%^%^GREEN%^l%^RESET%^"
        +"%^GREEN%^e%^RESET%^ trees. It is designed to open outwards";
  if (objectp(room)){
    desc += room->query_gate_condition();
  }
  if (query_exit("north")==TABAXROOM + OTHERSIDE){
    desc += " The gate is currently open, allowing you to head south out of the stockade";
  }
  return desc;
}

int knock_gate(string str){
  object * party;
  string party_name;
  if (str != "gate" && str != "on gate"){
    notify_fail("Knock on what?");
    return 0;
  }
  if (query_exit("south") == TABAXROOM + OTHERSIDE){
    tell_object(TP, "You don't need to"
                   +" knock, you can just walk south.");
    return 1;
  }
  party_name = TP->query_party();
  if (stringp(party_name)){
    party = (object *)PARTY_OB->query_party_members(party);
  }
  if (sizeof(party)<1){
    party = ({TP});
  }
  tell_room(TO, TPQCN + " knocks on the gate.", TP);
  tell_object(TP, "You knock on the gate.");
  call_out("usher", 2, party);
  return 1;
}

void usher (object * party){
  object mover, room;
  int i;
  tell_room(TO, "The gate swings open");
  if (sizeof(party)<1){
    return;
  }
  room = find_object_or_load(TABAXROOM + OTHERSIDE);
  if (!objectp(room)){
    tell_room(TO, "Error with destination room when you knocked on the gate."
                +" Please tell someone that Lujke is a silly lizard. Or make"
                +" a bug report or something");
    return;
  }
  for (i=0;i<sizeof(party);i++){
    mover = party[i];
    if (objectp(mover) && present(mover, TO)){
      tell_object(mover, "You are ushered through the gate");
      tell_room(TO, (string)mover->QCN + " is ushered through the gate", mover);
      mover->move(room);
      mover->force_me("look");
    }
  }
  tell_room(TO, "The gate swings closed again");
}

int open_gate(string str){
  object room;
  room = find_object_or_load(TABAXROOM + OTHERSIDE);
  if (str != "lever"){
    return notify_fail("pull what?");
  }
  if (objectp(room)){
    if ((int)room->query_gate()< 1){
      tell_room(TO, TPQCN + " pulls on the gate mechanism lever, but the gate"
                   +" is too damaged to respond", TP);
      tell_object(TP, "You pull on the gate mechanism lever, but the gate is"
                   +" too damaged to respond");
      return 1;
    }
  }
  switch(query_gate_open()){
  case 0:
    tell_room(TO, TPQCN + " pulls on the lever to open the gate", TP);
    tell_object(TP, "You pull on the lever, which will open the gate");
    call_out("open_gate2", 3);
    break;
  case 1:
    tell_room(TO, TPQCN + " pulls on the lever to close the gate", TP);
    tell_object(TP, "You pull on the lever, which will close the gate");
    call_out("close_gate", 3);
    break;
  }
  return 1;
}

void open_gate2(){
  object room;
  room = find_object_or_load(TABAXROOM + OTHERSIDE);
  tell_room(TO, "%^ORANGE%^With a slight groan, the stockade gate creaks open.");
  add_exit( TABAXROOM + OTHERSIDE, "south");
  if (objectp(room)){
    room->gate_opens();
  }
}

void close_gate(){
  object room;
  room = find_object_or_load(TABAXROOM + OTHERSIDE);
  tell_room(TO, "%^ORANGE%^With a slight groan, the stockade gate creaks closed.");
  remove_exit("south");
  if (objectp(room)){
    room->gate_closes();
  }
}

int check_open(){
  object room;
  room = find_object_or_load(TABAXROOM + OTHERSIDE);
  if (objectp(room)){
    return room->query_gate_open();
  } else {
    return 0;
  }
}

int go_on(){
  return 0;
}

